/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.sandraixchel.SonrisaDental.services;

import com.sandraixchel.SonrisaDental.exception.DateNotFoundException;
import com.sandraixchel.SonrisaDental.model.Appointment;
import com.sandraixchel.SonrisaDental.model.Appointment.AppointmentType;
import com.sandraixchel.SonrisaDental.repository.AppointmentRepository;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 *
 * @author Sandy
 */
@Service //Class to handle logic for checking apts
public class BookingService {

    private int[] possible_startTimes = {8, 9, 10, 11, 13, 14, 15, 16};

    @Autowired
    private AppointmentRepository appointmentRepository; //To inject the apt repo, it will be used to find existing apt in the data base

    //Lists all available apt slots. Returns a Map where the key is a date and the value is an Array List of available start times on that date
    public Map<String, ArrayList<String>> listAvailableAppointments(String selected_date, AppointmentType type) throws ParseException {

        //Create a new Map object, called free slots
        Map<String, ArrayList<String>> freeSlots = new HashMap<>();

        //String selected_date = "2023-07-17";  // Selected date by the user, passed by the front end
        //Creates a simpleDataFormat object, setting the format that the date object will have
        SimpleDateFormat date_formatter = new SimpleDateFormat("yyyy-MM-dd");

        //Creating a new calendar object at the current date and time
        Calendar cal = Calendar.getInstance();

        Date formattedDate = date_formatter.parse(selected_date); //Creates a date objectwith the value of selected_date, coverted from String
        cal.setTime(formattedDate);//takes in the date object with our selected date value

//        cal.setTime(date_formatter.parse(selected_date));
        //This code returns a time slot
        //Creates a date format object that will specify the format that the calendar object will have when converted to a String
        DateFormat time_formatter = new SimpleDateFormat("HH:mm");
        List<Appointment> bookedAppointments = appointmentRepository.findByDate(selected_date);// To fetch booked appointments only once and passes them wherever we need to

        ArrayList<String> availableTimesForDay = new ArrayList<String>();//Initiate an ArrayList to store the available time for a day generated by the for loop

        for (int i = 0; i < possible_startTimes.length; i++) { //loop to go through the possible start times Array and return each value as "hour"
            //setting our calendar time to 8am for example
            int hour = possible_startTimes[i]; // each go throught the loop we want to set 'hour' to the value on the current index 

            cal.set(Calendar.HOUR_OF_DAY, hour);
            //To add the hour e.g. 8:00, 9:00, 10:00 etc
            cal.set(Calendar.MINUTE, 00);

            //Convert the calendar date (result of the cal.getTime method) to the formatted String (specified in time_formatter)
            String time = time_formatter.format(cal.getTime());

            if (timeSlotAvailable(cal, type, bookedAppointments)) {
                availableTimesForDay.add(time);
            }

            //To add the half hour e.g. 8:30, 9:30, 10:30 etc
            cal.set(Calendar.MINUTE, 30);
            //Convert the calendar object to the formatted String
            time = time_formatter.format(cal.getTime());

            if (timeSlotAvailable(cal, type, bookedAppointments)) {
                availableTimesForDay.add(time);
            }

        }

        //Adding data to the Map
        freeSlots.put(selected_date, availableTimesForDay);

        //Printing the content in the map
        return freeSlots;

    }

    public boolean timeSlotAvailable(Calendar start_time, AppointmentType type, List<Appointment> bookedAppointments) throws ParseException {

        Calendar end_timeApt = (Calendar) start_time.clone();
        end_timeApt.add(Calendar.HOUR_OF_DAY, 1); // We just want to add an hour to the time of the copy of our calendar

        Calendar start_lunch = (Calendar) start_time.clone();
        start_lunch.set(Calendar.HOUR_OF_DAY, 12);// Set the time when lunch starts at
        start_lunch.set(Calendar.MINUTE, 00);//set the minutes to 00 

        Calendar end_lunch = (Calendar) start_time.clone();
        end_lunch.set(Calendar.HOUR_OF_DAY, 13);// Set the time when lunch ends at
        end_lunch.set(Calendar.MINUTE, 00);//set the minutes to 00 

        Calendar end_day = (Calendar) start_time.clone();
        end_day.set(Calendar.HOUR_OF_DAY, 17);// Set the time when lunch ends at
        end_day.set(Calendar.MINUTE, 00);//set the minutes to 00 

        //If end time is between 12:00 and 13:00 pm, return false
        if (end_timeApt.after(start_lunch) && end_timeApt.before(end_lunch)) {

            return false;
            //Else return true 

            //If time is after 17:00 pm, return false
        } else if (end_timeApt.after(end_day)) {

            return false;

            //If time clashes with any other appointment, return false
        } else if (clashesWithExistingAppointment(start_time, end_timeApt, bookedAppointments)) {

            return false;

            //The slot is available
        } else {
            return true;
        }

    }

    public boolean clashesWithExistingAppointment(Calendar start_time, Calendar end_time, List<Appointment> bookedAppointments) throws ParseException {

        SimpleDateFormat date_formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm");

        //Go through the bookedAppointments List
        for (int i = 0; i < bookedAppointments.size(); i++) {

            //Variable to store the information from de current Appoinment that the for loop is fetching
            Appointment currentAppointment = bookedAppointments.get(i);

            //Cretes a calendar object which we will set with the information form the appoinnet object we just pulled from the for loop
            Calendar currentCalendar = Calendar.getInstance();

            //We convert out date nd time information (String) into a date object
            Date formattedDate = date_formatter.parse(currentAppointment.getDate() + " " + currentAppointment.getStart_time());

            //We set our calendar with the information that we just converted into a Date object, since .setTime only takes Date objects as parameters 
            currentCalendar.setTime(formattedDate);

            //Cretes a calendar object which we will set with the information form the appoinnet object we just pulled from the for loop
            Calendar currentCalendar2 = Calendar.getInstance();

            //We convert out date nd time information (String) into a date object
            Date formattedDate2 = date_formatter.parse(currentAppointment.getDate() + " " + currentAppointment.getEnd_time());

            //We set our calendar with the information that we just converted into a Date object, since .setTime only takes Date objects as parameters 
            currentCalendar2.setTime(formattedDate2);

            //Not Working
            if ((currentCalendar.before(end_time) && currentCalendar2.after(end_time)) || (currentCalendar.before(start_time) && currentCalendar2.after(start_time))) {

                return true;

            }

        }

        //This will mean that the for loop did not encounter any clashes with booked appointments
        return false;

    }

}
